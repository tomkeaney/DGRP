---
title: "Calculating genetic trait correlations"
output: html_document
site: workflowr::wflow_site
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Load in necessary packages

```{r load packages}

library(Matrix)
library(tidyverse)
library(pheatmap) # for heatmaps
library(broom) # convert results of functions into tables
library(psych) # for getting p values and CIs for correlations
```

$~$

# Load in the data

For the analysis presented in our manuscript, we remove the metabolite traits measured in Jin _et al_ (2020) and the microbiome traits measured in Everett _et al_ (2020). We choose not to focus on the data from these studies because line means for these traits may also be associated with high levels of uncertainty, as they have only been measured in three and two flies per line respectively. They also make up ~ half of our dataset, which massively reduces our power to detect genetic correlations between traits. Calculating correlation coefficients with small samples is imprecise, therefore also choose to trim our analysis to only include traits that have been measured across \>79 lines.

The collection and cleaning of these data can be viewed [here](Data_collation.html).

```{r}
selected.dgrp.phenos_scaled <- read_csv("data/derived/selected.dgrp.phenos_scaled.csv")
```

$~$

# Estimating $r_g$

$~$

$r_g$ is the genetic correlation between a trait X and a trait Y.

We create a large trait correlation matrix using the `corr.test` function from the `psych` package. We calculate spearman correlation coefficients ($rho$) to estimate $r_g$, as these are more robust to non-normality than the default pearson method. The `corr.test` function also allows us to calculate confidence intervals and provides p-values adjusted for multiple testing for each bivariate correlation. 

Note that we perform ~260,000 bivariate correlations here, so the code takes a while to run. It runs substantially faster if `ci = FALSE` in `corr.test`

The code chunk below produces the csv files `rg.csv`.

We only show each correlation once i.e. this is not a mirrored correlation matrix.

```{r}

# Create a correlation matrix for all traits 


if(!file.exists("data/derived/rg.csv")){
  
  spearman_results <- corr.test(selected.dgrp.phenos_scaled %>% select(-line), adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits - each unique bivariate combination is presented once (twice in mirrored fashion is default)
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg <- tibble(traits, ci, ci_adjust)

  write_csv(rg, file = "data/derived/rg.csv")
} else rg <- read_csv("data/derived/rg.csv")

#view(rg %>% filter(str_detect(trait_1, "CT"),
              #p.adj < 0.05))

#view(rg %>% filter(p.adj < 0.05))
 

# if use = "pairwise.complete.obs" then the correlation or covariance between each pair of variables is computed using all complete pairs of observations on those variables. This can result in covariance or correlation matrices which are not positive semi-definite, as well as NA entries if there are no complete pairs for that pair of variables. For cov and var, "pairwise.complete.obs" only works with the "pearson" method.

# we could also simply run

#correlation.matrix <- round(cor(all.dgrp.phenos_scaled, use = "pairwise.complete.obs", method = "spearman"), 2)

```

# Estimating sex-specific $r_g$

Here we calculate genetic correlations only considering traits measured in the same sex (although traits that were pooled across the sexes are included in both of the correlation matrices. The code chunk below produces the csv files `rg_female.csv` and `rg_male.csv`.

We only show each correlation once i.e. this is not a mirrored correlation matrix.

```{r}

females <- selected.dgrp.phenos_scaled %>% select(!ends_with(".m"))
males <- selected.dgrp.phenos_scaled %>% select(!ends_with(".f"))

# Create a correlation matrix for female traits 


if(!file.exists("data/derived/rg_female.csv")){
  
  spearman_results <- corr.test(females %>% select(-line), adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg_female <- tibble(traits, ci, ci_adjust)

  write_csv(rg_female, file = "data/derived/rg_female.csv")
} else rg_female <- read_csv("data/derived/rg_female.csv")


# Create a correlation matrix for male traits


if(!file.exists("data/derived/rg_male.csv")){
  
  spearman_results <- corr.test(males %>% select(-line), adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg_male <- tibble(traits, ci, ci_adjust)

  write_csv(rg_male, file = "data/derived/rg_male.csv")
} else rg_male <- read_csv("data/derived/rg_male.csv")

```


```{r, eval=FALSE}
# Prepare to plot

paletteLength <- 50

# Load specific colours

myColor <- colorRampPalette(c(brewer.pal(9, "Purples")[7], "white", brewer.pal(9, "Oranges")[7]))(paletteLength)

# Get custom defined breaks

myBreaks <- c(seq(min(correlation.matrix, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(correlation.matrix, na.rm=T)/paletteLength, max(correlation.matrix, na.rm=T), length.out=floor(paletteLength/2)))
```


```{r, fig.height=50, fig.width=50, eval=FALSE}

# Make the heatmap

pheatmap::pheatmap(correlation.matrix,
                   col = myColor, breaks = myBreaks,
                   cutree_rows = 6, cutree_cols = 6)

**Figure 1**: Spearman correlation coefficients between >1100 traits measured across the DGRP. The tree shows hierarchical clustering of line means, where traits are split into *6* clusters, with grouping of the most similar traits. Note that the trees on the x and y axis are identical.
```
