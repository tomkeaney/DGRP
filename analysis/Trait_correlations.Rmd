---
title: "Calculating genetic trait correlations"
output: html_document
site: workflowr::wflow_site
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Load in necessary packages

```{r load packages}

library(Matrix)
library(tidyverse)
library(pheatmap) # for heatmaps
library(broom) # convert results of functions into tables
library(psych) # for getting p values and CIs for correlations
library(MetBrewer) # for colours
library(patchwork)
```

$~$

# Load and filter the data

For the analysis presented in our manuscript, we remove the metabolite traits measured in Jin _et al_ (2020) and Zhou _et al_ and the microbiome traits measured in Everett _et al_ (2020). **These intermediate (in the gap between genotype and phenotype) traits are either associated with high levels of uncertainty, as they have only been measured in three and two flies per line or are simply difficult to interpret in the context of our analysis.** They also make up ~ half of our dataset, which massively reduces our power to detect genetic correlations between traits. Calculating correlation coefficients with small samples is imprecise, therefore we also choose to trim our analysis to only include traits that have been measured across 80 or more lines.

The collection and cleaning of these data can be viewed [here](Data_collation.html).

```{r}
meta_data <- read_csv("data/derived/meta_data_for_all_traits.csv")

selected.dgrp.phenos_scaled <- read_csv("data/derived/all.dgrp.phenos_scaled.csv") %>% 
  filter(Reference %in% read_csv("data/input/references_in_original_database.csv")$Reference) %>% # restrict to only papers in the original database
  left_join(meta_data, by = c("Trait", "Reference")) %>% 
  filter(Reference != "Jin et al (2020) PLOS Genetics" &    # Exclude these metabolite and microbiome studies
           Reference != "Zhou et al (2020) Genome Research" & 
           Reference != "Everett et al (2020) Genome Research" & 
           `# lines measured` >= 80) %>%     # Filter by number of lines measured
  select(line, Trait, trait_value) %>% 
  spread(Trait, trait_value)
```


$~$

# Estimating $r_g$

$~$

$r_g$ is the genetic correlation between a trait X and a trait Y.

We create a large trait correlation matrix using the `corr.test` function from the `psych` package. We calculate Spearman correlation coefficients ($rho$) to estimate $r_g$, as these are more robust to non-normality than the default Pearson method. The `corr.test` function also allows us to calculate confidence intervals and provides p-values adjusted for multiple testing for each bivariate correlation. 

Note that we perform ~260,000 bivariate correlations here, so the code takes a while to run. It runs substantially faster if `ci = FALSE` in `corr.test`

The code chunk below produces the csv files `rg.csv`.

We only show each correlation once i.e. this is not a mirrored correlation matrix.

```{r}

# Create a correlation matrix for all traits 

if(!file.exists("data/derived/rg.csv")){
  
  spearman_results <- corr.test(selected.dgrp.phenos_scaled %>% 
                                  select(-line), 
                                adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits - each unique bivariate combination is presented once (twice in mirrored fashion is default)
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg <- tibble(traits, ci, ci_adjust)

  write_csv(rg, file = "data/derived/rg.csv")
} else rg <- read_csv("data/derived/rg.csv")

#view(rg %>% filter(str_detect(trait_1, "mass"),
 #             p < 0.05))

#view(rg %>% filter(p.adj < 0.05))

```

# Estimating sex-specific $r_g$

Here we calculate genetic correlations only considering traits measured in the same sex (although traits that were pooled across the sexes are included in both of the correlation matrices. The code chunk below produces the csv files `rg_female.csv` and `rg_male.csv`.

We only show each correlation once i.e. this is not a mirrored correlation matrix.

```{r}

females <- selected.dgrp.phenos_scaled %>% select(!ends_with(".m"))
males <- selected.dgrp.phenos_scaled %>% select(!ends_with(".f"))

# Create a correlation matrix for female traits 


if(!file.exists("data/derived/rg_female.csv")){
  
  spearman_results <- corr.test(females %>% select(-line), adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg_female <- tibble(traits, ci, ci_adjust)

  write_csv(rg_female, file = "data/derived/rg_female.csv")
} else rg_female <- read_csv("data/derived/rg_female.csv")


# Create a correlation matrix for male traits


if(!file.exists("data/derived/rg_male.csv")){
  
  spearman_results <- corr.test(males %>% select(-line), adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg_male <- tibble(traits, ci, ci_adjust)

  write_csv(rg_male, file = "data/derived/rg_male.csv")
} else rg_male <- read_csv("data/derived/rg_male.csv")

```

$~$

# Plotting the strength of $r_g$

$~$

Create correlation matrices, first with all the data, then stratified by sex.

```{r}
# we could also simply run

correlation.matrix <- round(cor(selected.dgrp.phenos_scaled %>% select(-line), use = "pairwise.complete.obs", method = "spearman"), 2)

correlation.matrix_females <- round(cor(females %>% select(-line), use = "pairwise.complete.obs", method = "spearman"), 2)

correlation.matrix_males <- round(cor(males %>% select(-line), use = "pairwise.complete.obs", method = "spearman"), 2)

# if use = "pairwise.complete.obs" then the correlation or covariance between each pair of variables is computed using all complete pairs of observations on those variables. This can result in covariance or correlation matrices which are not positive semi-definite, as well as NA entries if there are no complete pairs for that pair of variables. For cov and var, "pairwise.complete.obs" only works with the "pearson" method.
```

Build the plots

```{r, eval=TRUE}
# Prepare to plot

paletteLength <- 50

# Load specific colours

myColor_met_brewer <- met.brewer("OKeeffe1", n = paletteLength, type = "continuous", direction = -1)

# Get custom defined breaks

myBreaks <- c(seq(min(correlation.matrix, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(correlation.matrix, na.rm=T)/paletteLength, max(correlation.matrix, na.rm=T), length.out=floor(paletteLength/2)))

# create a trait guild annotation column, need this to be a data.frame rather than a tibble for some reason 

Trait_guilds <- meta_data %>%
  as.data.frame() %>% 
  select(Trait, `Trait guild`)

my_guilds <- data.frame(row.names = Trait_guilds[, 1], Guild = Trait_guilds[, 2])

my_guild_colours <- list(Guild = c(`Activity` = "#EF9A9A",
                                   `Behavioural` = "#AB47BC",
                                   `CHC` = "#3F51B5",
                                   `Drug response` = "#26C6DA", 
                                   `Genomic` = "#00796B",
                                   `Insecticide response` = "#9CCC65",
                                   `Life history` = "#76FF03",
                                   `Metabolome` = "#FFEE58",
                                   `Microbiome` = "#FFCC80",
                                   `Morphological` = "#EF6C00",
                                   `Pathogen response` ="#DD2C00",  
                                   `Physiological` = "#6D4C41",
                                   `Sensory`  = "#D7CCC8",
                                   `Stress response` = "#EEEEEE",
                                   `Temperature related` = "#78909C"))
                             
```


```{r, fig.height=25, fig.width=30, eval=TRUE}

# Make the heatmap

heatmap_females <- pheatmap::pheatmap(correlation.matrix_females,
                            col = myColor_met_brewer, breaks = myBreaks,
                            cutree_rows = 6, cutree_cols = 6,
                            annotation_col = my_guilds,
                            fontsize = 6, annotation_colors = my_guild_colours,
                            treeheight_row = 0)


heatmap_males <- pheatmap::pheatmap(correlation.matrix_males,
                          col = myColor_met_brewer, breaks = myBreaks,
                          cutree_rows = 6, cutree_cols = 6,
                          annotation_col = my_guilds,
                          fontsize = 6, annotation_colors = my_guild_colours)

```


