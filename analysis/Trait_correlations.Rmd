---
title: "Calculating genetic trait correlations"
output: html_document
site: workflowr::wflow_site
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Load in necessary packages

```{r load packages}
library(Matrix)
library(tidyverse)
library(pheatmap) # for heatmaps
library(broom) # convert results of functions into tables
library(psych) # for getting p values and CIs for correlations
library(RColorBrewer) 
library(patchwork)
library(grid)
library(brms)
library(future.apply)

# A function to randomly select one trait per study, from among the traits measured in at least 80 DGRP lines
get_independent_traits <- function(){
  set.seed(1) # Set the seed for reproducibility
  read_csv("data/derived/meta_data_for_all_traits.csv") %>%
    # restrict to only papers in the original database, i.e. not those added post-publication:
    filter(Reference %in% read_csv("data/input/references_in_original_database.csv")$Reference) %>% 
    filter(`# lines measured` >= 80) %>% # Only analyse traits that measured at least 80 lines
    group_by(Reference) %>%
    sample_n(1) %>% # Randomly sample one phenotype per study
    pull(Trait) %>% sort() 
}

# For saving pheatmaps to a PDF file
save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   
   my_gtable <- x$gtable
   # my_gtable$grobs[[4]]$gp <- gpar(fontfamily = nice_font, fontsize = 8) 
   # my_gtable$grobs[[5]]$gp <- gpar(fontfamily = nice_font, fontsize = 8)
   pdf(filename, width = width, height = height)
   grid::grid.newpage()
   grid::grid.draw(my_gtable)
   dev.off()
}
```

$~$

# Load and filter the data

For the genetic correlation matrix presented in our manuscript, we first filtered the dataset to just the set of phenotypic traits that were measured in at least 80 DGRP lines. We then randomly selected a single phenotypic trait per study, given that traits measured in the same study often show...


<!-- remove the metabolite traits measured in Jin _et al_ (2020) and Zhou _et al_ and the microbiome traits measured in Everett _et al_ (2020). **We choose not to focus on the data from these studies because line means for these traits may also be associated with high levels of uncertainty, as they have only been measured in three and two flies per line respectively.** They also make up ~ half of our dataset, which massively reduces our power to detect genetic correlations between traits. Calculating correlation coefficients with small samples is imprecise, therefore also choose to trim our analysis to only include traits that have been measured across 80 or more lines. -->

The collection and cleaning of these data can be viewed [here](Data_collation.html).

```{r}
meta_data <- read_csv("data/derived/meta_data_for_all_traits.csv")

papers_to_exclude <- c("Jin et al (2020) PLOS Genetics", 
                       "Zhou et al (2020) Genome Research", 
                       "Everett et al (2020) Genome Research",
                       "Dembeck et al (2015) eLife")

# Get a list of all traits measured in at least 80 lines 
# (there are >900 traits, though many are microbiome or metabolome traits from 3 particular papers)
all_traits <- read_csv("data/derived/all.dgrp.phenos_scaled.csv") %>% 
  # restrict to only papers in the original database, i.e. not those added post-publication:
  filter(Reference %in% read_csv("data/input/references_in_original_database.csv")$Reference) %>% 
  filter(!(Reference %in% papers_to_exclude)) %>%  # Exclude the 4 microbiome/metabolome/CHC papers
  left_join(meta_data, by = c("Trait", "Reference")) %>% 
  filter(`# lines measured` >= 80) %>%     # Filter by number of lines measured
  select(line, Trait, trait_value) %>% 
  spread(Trait, trait_value) %>% 
  as.data.frame()

trait_combos <- as_tibble(as.data.frame(t(combn(names(all_traits)[-1], 2)))) %>% 
  rename(trait1 = V1, trait2 = V2) %>% 
  as.data.frame()

big_corr_matrix <-  cor(all_traits %>% select(-line), 
        use = "pairwise.complete.obs", 
        method = "spearman")

library(boot)
se <- function(x) sd(x) / sqrt(length(x))

cor_bootstrapped_se <- function(x, y){
  dat <- data.frame(x = x, y = y)
  dat <- dat[complete.cases(dat), ]
  if(nrow(dat) == 0) return(NA)
  se(boot(
    dat, 
    statistic = function(data, i) {
      
      cor(data[i, "x"], data[i, "y"], 
          method = 'spearman', 
          use = "pairwise.complete.obs")
      
    }, 
    R = 1000)$t[,1])
}

# tryBootstrap <- function(x, y) {
#     out <- tryCatch(
#         {
#             cor_bootstrapped_se(x, y)
#         },
#         error=function(cond) {
#             message("Here's the original error message:")
#             message(cond)
#             return(NA)
#         },
#         finally={}
#     )    
#     return(out)
# }


if(!file.exists("data/derived/correlation_SEs.rds")){
  n_combos <- nrow(trait_combos)
  plan(multisession)
  
  correlation_SEs <- future_lapply(
    1:n_combos, 
    function(i){
      print(i)
      cor_bootstrapped_se(
        all_traits[, trait_combos[i,1]],
        all_traits[, trait_combos[i,2]]
      )
    }, future.seed = TRUE) %>% 
    do.call("c", .) 
  
  saveRDS(correlation_SEs, "data/derived/correlation_SEs.rds")
} else correlation_SEs <- readRDS("data/derived/correlation_SEs.rds")



pairwise_corrs <- trait_combos %>% 
  left_join(
    big_corr_matrix %>% 
      as.data.frame() %>% 
      rownames_to_column("trait1") %>% 
      gather(trait2, corr, -trait1), 
    by = c("trait1", "trait2")) %>% 
  mutate(corr_SE = correlation_SEs) %>% 
  left_join(meta_data %>% 
              select(-`Trait description`, -`# lines measured`), 
            by = c("trait1" = "Trait")) %>% 
  rename(sex_trait1 = Sex, guild_trait1 = `Trait guild`, study_trait1 = Reference) %>% 
  left_join(meta_data %>% 
              select(-`Trait description`, -`# lines measured`), 
            by = c("trait2" = "Trait")) %>% 
  rename(sex_trait2 = Sex, guild_trait2 = `Trait guild`, study_trait2 = Reference) %>% 
  mutate(same_study = ifelse(study_trait1==study_trait2, "Same_study", "Different_study"),
         same_sex = ifelse(sex_trait1==sex_trait2, "Same_sex", "Not_same_sex"),
         same_guild = ifelse(guild_trait1==guild_trait2, "Same_guild", "Different_guild"))

lm(corr  ~ same_study * same_guild * same_sex,
   weights = 1 / corr_SE, data =pairwise_corrs) -> big_model



# big_corr_model <- brm(
#   corr|weights(1 / corr_SE)  ~ same_study * same_guild * same_sex,
#   data = pairwise_corrs,
#   family = gaussian,
#   prior = prior(normal(0, 0.5), class = b),
#   iter = 6000, warmup = 2000, chains = 4, 
#   cores = 1, seed = 1, 
#   control = list(adapt_delta = 0.95, max_treedepth = 12))
# pp_check(big_corr_model)

newdat <- pairwise_corrs %>% 
  select(starts_with("same_")) %>% 
  distinct() %>% 
  mutate(par = paste("V", 1:n(), sep=""))

library(emmeans)

data.frame(newdat, as.data.frame(predict(big_model, newdata = newdat, se.fit = T)[1:2]))

pd <- position_dodge(0.2)
gen_corr_predictions_plot <- 
  fitted(big_corr_model, summary = F, newdata = newdat) %>% 
  as.data.frame() %>% 
  gather(par, fitted) %>% 
  left_join(newdat, by = "par") %>% 
  group_by(same_study, same_sex, same_guild) %>% 
  summarise(median = median(fitted), 
            lower_95 = quantile(fitted, probs = 0.025),
            upper_95 = quantile(fitted, probs = 0.975),
            .groups = "drop") %>% 
  mutate_at(vars(starts_with("same")), ~ str_replace_all(.x, "_", " ")) %>% 
  mutate(same_study = replace(same_study, same_study == "Different study", "Traits measured in a different study"),
         same_study = replace(same_study, same_study == "Same study", "Traits measured in the same study")) %>% 
  ggplot(aes(same_guild, median, colour = same_sex)) + 
  facet_wrap(~same_study) +
  geom_errorbar(aes(ymin = lower_95, ymax = upper_95), width = 0, position = pd) +
  geom_point(position = pd) + 
  scale_colour_brewer(palette = "Set2", name = "Traits measured in\nthe same sex?") +
  xlab("Traits in the same trait guild?") +
  ylab("Median genetic correlation\n(\u00B1 95% CIs)") +
  theme_bw() + 
  theme(panel.grid.major.x =  element_blank(), strip.background = element_blank())

grid.arrange(
  gen_corr_predictions_plot,
  pairwise_corrs %>% 
    ggplot(aes(corr)) + 
    geom_histogram(bins = 100, colour = "grey20") +
    facet_wrap(~ same_study, scales = "free_y", ncol = 2),
 ncol=1)

paletteLength <- 50
myColor <- colorRampPalette(c(brewer.pal(9, "Purples")[6], 
                              "white", 
                              brewer.pal(9, "Oranges")[7]))(paletteLength)

myBreaks <- c(seq(min(big_corr_matrix, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(big_corr_matrix[big_corr_matrix<0.999], na.rm=T)/paletteLength, 
                  max(big_corr_matrix[big_corr_matrix<0.999], na.rm=T), 
                  length.out=floor(paletteLength/2)))

annotations <- meta_data %>% 
  select(Trait, Sex, Trait_guild = `Trait guild`, Reference) %>% 
  mutate(Sex = replace(Sex, Sex == "Pooled", "Both")) %>% 
  as.data.frame()
rownames(annotations) <- annotations$Trait
annotations <- annotations %>% select(-Trait) 

my_guild_colours <- list(
  Trait_guild = c(`Activity` = "#EF9A9A",
                  `Behavioural` = "#AB47BC",
                  `CHC` = "#3F51B5",
                  `Drug response` = "#26C6DA", 
                  `Genomic` = "#00796B",
                  `Insecticide response` = "#9CCC65",
                  `Life history` = "#76FF03",
                  `Metabolome` = "#FFEE58",
                  `Microbiome` = "#FFCC80",
                  `Morphological` = "#EF6C00",
                  `Pathogen response` ="#DD2C00",  
                  `Physiological` = "#6D4C41",
                  `Sensory`  = "#D7CCC8",
                  `Stress response` = "#EEEEEE",
                  `Temperature related` = "#78909C"),
  Sex = c(`Both` = "purple",
          `Female` = "pink",
          `Male` = "skyblue"))


heatmap_both <- pheatmap::pheatmap(
  big_corr_matrix,
  border_color = "grey20",
  show_rownames=F, show_colnames=F,
  cellwidth = 1.3, cellheight = 1.3,
  col = myColor, breaks = myBreaks, 
  cutree_rows = 6, cutree_cols = 6,
  annotation_col = annotations, annotation_row = annotations,
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0)


save_pheatmap_pdf(heatmap_both, "test.pdf", width = 12, height = 12)

```

```{r}
# Randomly select one trait per study, from among the traits measured in at least 80 DGRP lines
independent_traits <- get_independent_traits()
independ_traits <- all_traits[, names(all_traits) %in% independent_traits]
independ_corr_matrix <-  cor(independ_traits, 
        use = "pairwise.complete.obs", 
        method = "spearman")

trait_combos_independent <- as_tibble(as.data.frame(t(combn(names(independ_traits)[-1], 2)))) %>% 
  rename(trait1 = V1, trait2 = V2)


pairwise_corrs_independent <- trait_combos_independent %>% 
  left_join(
    independ_corr_matrix %>% 
      as.data.frame() %>% 
      rownames_to_column("trait1") %>% 
      gather(trait2, corr, -trait1), 
    by = c("trait1", "trait2")) %>% 
  left_join(meta_data %>% 
              select(-`Trait description`, -`# lines measured`), 
            by = c("trait1" = "Trait")) %>% 
  rename(sex_trait1 = Sex, guild_trait1 = `Trait guild`, study_trait1 = Reference) %>% 
  left_join(meta_data %>% 
              select(-`Trait description`, -`# lines measured`), 
            by = c("trait2" = "Trait")) %>% 
  rename(sex_trait2 = Sex, guild_trait2 = `Trait guild`, study_trait2 = Reference) %>% 
  mutate(same_sex = ifelse(sex_trait1==sex_trait2, "Same_sex", "Not_same_sex"),
         same_guild = ifelse(guild_trait1==guild_trait2, "Same_guild", "Different_guild"))

indep_corr_model <- brm(corr ~ same_guild + same_sex, 
             data = pairwise_corrs_independent,
             family = gaussian,
             prior = prior(normal(0, 0.5), class = b),
             iter = 6000, warmup = 2000, chains = 4, 
             cores = 1, seed = 1, control = list(adapt_delta = 0.95, 
                                                 max_treedepth = 12))
pp_check(indep_corr_model)

lm(corr  ~ same_guild * same_sex,
   weights = 1 / corr_SE, data =pairwise_corrs_independent) -> big_model


myBreaks2 <- c(seq(min(independ_corr_matrix, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(independ_corr_matrix[independ_corr_matrix<0.999], na.rm=T)/paletteLength, 
                  max(independ_corr_matrix[independ_corr_matrix<0.999], na.rm=T), 
                  length.out=floor(paletteLength/2)))

heatmap_independent <- pheatmap::pheatmap(
  independ_corr_matrix,
  border_color = "grey20",
  # cellwidth = 3, cellheight = 3,
  col = myColor, breaks = myBreaks2,
  cutree_rows = 6, cutree_cols = 6,
  annotation_col = annotations[,1:2], annotation_row = annotations[,1:2],
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0)
save_pheatmap_pdf(heatmap_independent, "test3.pdf", width = 12, height = 12)


newdat <- pairwise_corrs %>% 
  select(starts_with("same_")) %>% 
  distinct() %>% 
  mutate(par = paste("V", 1:n(), sep=""))


fitted(indep_corr_model, summary=F, newdata = newdat) %>% 
  as.data.frame() %>% gather(par, fitted) %>% 
  left_join(newdat, by = "par") %>% 
  group_by(same_sex, same_guild) %>% 
  summarise(median = median(fitted), 
            lower_95 = quantile(fitted, probs = 0.025),
            upper_95 = quantile(fitted, probs = 0.975),
            .groups = "drop") %>% 
  mutate_at(vars(starts_with("same")), ~ str_replace_all(.x, "_", " ")) %>% 
  ggplot(aes(same_guild, median, colour = same_sex)) + 
  geom_errorbar(aes(ymin = lower_95, ymax = upper_95), width = 0, position = pd) +
  geom_point(position = pd) + ylab("Mean genetic correlation (\u00B1 95% CIs)")

```





$~$

# Plotting the strength of $r_g$

$~$

Create correlation matrices, first with all the data, then stratified by sex.

```{r}

correlation.matrix <- round(cor(
  independ_traits_both_sexes, 
  use = "pairwise.complete.obs", method = "spearman"), 2)
# correlation.matrix[correlation.matrix==1] <- NA

correlation.matrix_females <- round(cor(
  independ_female_traits, 
  use = "pairwise.complete.obs", method = "spearman"), 2)
# correlation.matrix_females[correlation.matrix_females==1] <- NA

correlation.matrix_males <- round(cor(
  independ_male_traits, 
  use = "pairwise.complete.obs", method = "spearman"), 2)
# correlation.matrix_males[correlation.matrix_males==1] <- NA

# if use = "pairwise.complete.obs" then the correlation or covariance between each pair of variables is computed using all complete pairs of observations on those variables. This can result in covariance or correlation matrices which are not positive semi-definite, as well as NA entries if there are no complete pairs for that pair of variables. For cov and var, "pairwise.complete.obs" only works with the "pearson" method.
```

Build the plots

```{r, eval=TRUE}
# Prepare to plot

paletteLength <- 50

# Load specific colours

# myColor_met_brewer <- met.brewer("OKeeffe1", n = paletteLength, type = "continuous", direction = -1)
library(RColorBrewer)
myColor <- colorRampPalette(c(brewer.pal(9, "Purples")[6], "white", brewer.pal(9, "Oranges")[7]))(paletteLength)

# Get custom defined breaks

myBreaks <- c(seq(min(correlation.matrix, na.rm=T), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(correlation.matrix[correlation.matrix!=1], na.rm=T)/paletteLength, max(correlation.matrix[correlation.matrix!=1], na.rm=T), 
                  length.out=floor(paletteLength/2)))

# create a trait guild annotation column, need this to be a data.frame rather than a tibble for some reason 

Trait_guilds <- meta_data %>%
  as.data.frame() %>% 
  select(Trait, `Trait guild`)

annot_guilds <- data.frame(row.names = Trait_guilds[, 1], Guild = Trait_guilds[, 2])
annot_sexes <- data.frame(row.names = Trait_guilds[, 1], x =  Trait_guilds[, 1], Sex = "Both") %>% 
  mutate(Sex = replace(Sex, substr(x, nchar(x)-1, nchar(x)) == ".f", "Females"),
         Sex = replace(Sex,  substr(x, nchar(x)-1, nchar(x)) == ".m", "Males")) %>% 
  select(-x)
annotations <- cbind(annot_guilds, annot_sexes)

my_guild_colours <- list(Guild = c(`Activity` = "#EF9A9A",
                                   `Behavioural` = "#AB47BC",
                                   `CHC` = "#3F51B5",
                                   `Drug response` = "#26C6DA", 
                                   `Genomic` = "#00796B",
                                   `Insecticide response` = "#9CCC65",
                                   `Life history` = "#76FF03",
                                   `Metabolome` = "#FFEE58",
                                   `Microbiome` = "#FFCC80",
                                   `Morphological` = "#EF6C00",
                                   `Pathogen response` ="#DD2C00",  
                                   `Physiological` = "#6D4C41",
                                   `Sensory`  = "#D7CCC8",
                                   `Stress response` = "#EEEEEE",
                                   `Temperature related` = "#78909C"),
                         Sex = c(`Both` = "purple",
                                 `Females` = "pink",
                                 `Males` = "skyblue"))
                             
```


```{r, fig.height=25, fig.width=30, eval=TRUE}

# Make the heatmap




# In clustering analysis, you first need to decide how many clusters to pick. I got this code from here:
# https://statsandr.com/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r/
# It's the consensus-based method
library(factoextra)
library(NbClust)
library(parameters)
n_clust <- n_clusters(as.data.frame(correlation.matrix),
                      package = c("easystats", "NbClust", "mclust"),
                      standardize = FALSE, n_max = 15)
plot(n_clust) #, 2 or 4 clusters are most sensible. Let's pick 9 as it seems a good number for our number of traits!

plot(n_clusters_elbow(as.data.frame(correlation.matrix)))
plot(n_clusters_elbow(as.data.frame(correlation.matrix_females)))
plot(n_clusters_elbow(as.data.frame(correlation.matrix_males)))


num_clusters <- 2

heatmap_both <- pheatmap::pheatmap(
  correlation.matrix,
  border_color = "grey20",
  cellwidth = 6, cellheight = 6,
  col = myColor, breaks = myBreaks, 
  cutree_rows = num_clusters, cutree_cols = num_clusters,
  annotation_col = annotations, annotation_row = annotations,
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0)

heatmap_females <- pheatmap::pheatmap(
  correlation.matrix_females,
  border_color = "grey20",
  cellwidth = 6, cellheight = 6,
  col = myColor, breaks = myBreaks,
  cutree_rows = num_clusters, cutree_cols = num_clusters,
  annotation_col = annot_guilds, annotation_row = annot_guilds,
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0)

heatmap_males <- pheatmap::pheatmap(
  correlation.matrix_males,
  border_color = "grey20",
  cellwidth = 6, cellheight = 6,
  col = myColor, breaks = myBreaks, legend = F, annotation_legend = F,
  cutree_rows = 3, cutree_cols = 3,
  annotation_col = annot_guilds, annotation_row = annot_guilds,
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0)

save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   
   my_gtable <- x$gtable
   # my_gtable$grobs[[4]]$gp <- gpar(fontfamily = nice_font, fontsize = 8) 
   # my_gtable$grobs[[5]]$gp <- gpar(fontfamily = nice_font, fontsize = 8)
   pdf(filename, width = width, height = height)
   grid::grid.newpage()
   grid::grid.draw(my_gtable)
   dev.off()
}

library(grid)
pheatmap::pheatmap(
  correlation.matrix,
  border_color = "grey20",
  cellwidth = 6.7, cellheight = 6.7,
  col = myColor, breaks = myBreaks,
  cutree_rows = num_clusters, cutree_cols = num_clusters,
  annotation_col = annot_guilds, annotation_row = annot_guilds,
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0) %>%
  save_pheatmap_pdf("test.pdf", width = 15, height = 15)


pheatmap::pheatmap(
  correlation.matrix_females,
  border_color = "grey20",
  cellwidth = 6, cellheight = 6,
  col = myColor, breaks = myBreaks,
  cutree_rows = num_clusters, cutree_cols = num_clusters,
  annotation_col = annot_guilds, annotation_row = annot_guilds,
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0) %>%
  save_pheatmap_pdf("test.pdf", width = 7, height = 7)

pheatmap::pheatmap(
  correlation.matrix_males,
  border_color = "grey20",
  cellwidth = 6, cellheight = 6,
  col = myColor, breaks = myBreaks, legend = F, annotation_legend = F,
  cutree_rows = 3, cutree_cols = 3,
  annotation_col = annot_guilds, annotation_row = annot_guilds,
  fontsize = 6, annotation_colors = my_guild_colours,
  treeheight_row = 0) %>%
  save_pheatmap_pdf("test2.pdf", width = 7, height = 7)


```

<!-- End of Luke -->










$~$

# Estimating $r_g$

$~$

$r_g$ is the genetic correlation between a trait X and a trait Y.

We create a large trait correlation matrix using the `corr.test` function from the `psych` package. We calculate Spearman correlation coefficients ($rho$) to estimate $r_g$, as these are more robust to non-normality than the default Pearson method. The `corr.test` function also allows us to calculate confidence intervals and provides p-values adjusted for multiple testing for each bivariate correlation. 

Note that we perform ~260,000 bivariate correlations here, so the code takes a while to run. It runs substantially faster if `ci = FALSE` in `corr.test`

The code chunk below produces the csv files `rg.csv`.

We only show each correlation once i.e. this is not a mirrored correlation matrix.

```{r}

# Create a correlation matrix for all traits 

if(!file.exists("data/derived/rg.csv")){
  
  spearman_results <- corr.test(selected.dgrp.phenos_scaled %>% 
                                  select(-line), 
                                adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits - each unique bivariate combination is presented once (twice in mirrored fashion is default)
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg <- tibble(traits, ci, ci_adjust)

  write_csv(rg, file = "data/derived/rg.csv")
} else rg <- read_csv("data/derived/rg.csv")

#view(rg %>% filter(str_detect(trait_1, "mass"),
 #             p < 0.05))

#view(rg %>% filter(p.adj < 0.05))

```

# Estimating sex-specific $r_g$

Here we calculate genetic correlations only considering traits measured in the same sex (although traits that were pooled across the sexes are included in both of the correlation matrices. The code chunk below produces the csv files `rg_female.csv` and `rg_male.csv`.

We only show each correlation once i.e. this is not a mirrored correlation matrix.

```{r}
females <- selected.dgrp.phenos_scaled %>% select(!ends_with(".m"))
males <- selected.dgrp.phenos_scaled %>% select(!ends_with(".f"))

# Create a correlation matrix for female traits 


if(!file.exists("data/derived/rg_female.csv")){
  
  spearman_results <- corr.test(females %>% select(-line), adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg_female <- tibble(traits, ci, ci_adjust)

  write_csv(rg_female, file = "data/derived/rg_female.csv")
} else rg_female <- read_csv("data/derived/rg_female.csv")


# Create a correlation matrix for male traits


if(!file.exists("data/derived/rg_male.csv")){
  
  spearman_results <- corr.test(males %>% select(-line), adjust = "holm", method = "spearman", ci = TRUE)
  
  # Wrangling the data into a useable tibble
  
  # First make a function to find the desired combinations of traits
  
  expand.grid.unique <- function(x, y, include.equals=FALSE)
  {
    x <- unique(x)
    y <- unique(y)
    g <- function(i)
    {
      z <- setdiff(y, x[seq_len(i-include.equals)])
      
      if(length(z)) cbind(x[i], z, deparse.level=0)
    }
    do.call(rbind, lapply(seq_along(x), g))
  }
  
  # Use the function to find the desired combinations that match up with the spearman_results$ci2 output
  
  traits <- expand.grid.unique(spearman_results$r %>% rownames(),
                               spearman_results$r %>% colnames()) %>% 
    as_tibble() %>% 
    rename(trait_1 = V1,
           trait_2 = V2)
  
  # pull the relevant stats from the psych object
  
  ci <- spearman_results$ci2 %>%
    as_tibble()
  
  # adjusted CIs aren't provided in the ci2 object, so we specifically call them
  
  ci_adjust <- spearman_results$ci.adj %>% 
    as_tibble()
  
  # combine everything into the final output
  
  rg_male <- tibble(traits, ci, ci_adjust)

  write_csv(rg_male, file = "data/derived/rg_male.csv")
} else rg_male <- read_csv("data/derived/rg_male.csv")
```




